<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.3 on Wed Sep 14 19:26:30 2011 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>test_hiihat_6d_synthetic_ut__define.pro (HiiHAT)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="test_hiihat_6d_synthetic_ut__define.pro (HiiHAT)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="test_hiihat_6d_synthetic_ut__define:source"></a>pro test_hiihat_6d_synthetic_ut__define
<span class="comments">;+</span>
<span class="comments">; Unit test entry point definition for synthetic multispectral</span>
<span class="comments">; image. Initializes MGTestCase structure for MGUnit unit test. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Jan 3, 2011 (BDB): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Examples:</span>
<span class="comments">;   This unit test can be run with the following command:</span>
<span class="comments">;</span>
<span class="comments">;   mgunit, 'test_hiihat_6d_synthetic_ut'</span>
<span class="comments">;</span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
  compile_opt strictarr
  
  define = { test_hiihat_6d_synthetic_ut, $
             datadir:'', tmpdir:'', verbose:0, debug:0, sep:'', $
             coalesce_threshold:0, permute_segments: 0, $
             inherits MGTestCase } 
end

<a id="test_hiihat_6d_synthetic_ut::test_0_init:source"></a>function test_hiihat_6d_synthetic_ut::test_0_init
<span class="comments">;+</span>
<span class="comments">; Initialization test and parameters for 6d synthetic dataset. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Initializes parameters used by the 6d-synthetic unit tests and</span>
<span class="comments">;   verifies that the directory containing the data is</span>
<span class="comments">;   accessible. This test is run before any other 6-d synthetic</span>
<span class="comments">;   unit tests are executed. </span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Jan 3, 2011 (BDB): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>

  hh_path = hiihat_get_config_parm('hiihat_path')
  assert, file_test(hh_path), "HiiHAT directory missing"
  self.verbose = 0
  self.debug = 0
  self.sep = path_sep()
  self.datadir = hh_path+'data'+self.sep+'6d_synthetic'+self.sep
  assert, file_test(self.datadir), "Data directory missing"
  self.tmpdir = getenv("IDL_TMPDIR")
  self.coalesce_threshold = 0
  self.permute_segments = 0 <span class="comments">;; do not permute segments</span>
  envi_delete_rois, /all <span class="comments">;; get rid of any old rois</span>

  return, 1
end


<a id="test_hiihat_6d_synthetic_ut::test_segmentation:source"></a>function test_hiihat_6d_synthetic_ut::test_segmentation
<span class="comments">;+</span>
<span class="comments">; Tests segmentation functions on 11 class noisy 6d-synthetic data.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Tests the felzenszwalb segmentation algorithm on a 6-dimensional </span>
<span class="comments">;   synthetic image. The synthetic image contains 11 noisy classes,</span>
<span class="comments">;   including one single pixel class, which are all separable with the</span>
<span class="comments">;   squared Euclidean metric. This function tests to make sure that</span>
<span class="comments">;   the segmentation algorithm produces 11 "pure" segments (a pure</span>
<span class="comments">;   segment consists of pixels from only one class). </span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Jan 3, 2011 (BDB): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
  compile_opt strictarr

  dist_metric='euclidean'

  <span class="comments">;; assume test failure</span>
  test_pure=0
  test_nseg=0

  <span class="comments">;; set up parameters for 11 class noisy data</span>
  k = 11
  kstr = string(k,format='(%"%d")')
  nstr = "-n_m0v10"
  img_base=kstr+'class_noisy'+self.sep+''+kstr+'class-layout1'
  img_npath = self.datadir+img_base+nstr+'.img'
  img_classpath=self.datadir+img_base+'.map.img'

  <span class="comments">;; open noisy image and class map</span>
  envi_open_file, img_npath, r_fid=fid_n 
  envi_open_file, img_classpath, r_fid=fid_class

  <span class="comments">;; get input file dimensions</span>
  envi_file_query, fid_n, dims=dims, ns=ns, nl=nl, nb=nb

  <span class="comments">;; load class map data </span>
  img_class=envi_get_data(fid=fid_class, dims=dims, pos=[0])

  <span class="comments">;; get class means</span>
  hiihat_segment_spectra, fid_n, fid_class, spectra=class_means, $
                          verbose=self.verbose, variances=variances

  <span class="comments">;; do segmentation, allowing for single pixel classes</span>
  min_size=1
  c = 10
  hiihat_segment_felzenszwalb, fid_n, C, min_size, dist_metric, $
                               r_fid=fid_seg, verbose=self.verbose, /in_memory, $
                               permute_segments=self.permute_segments

  <span class="comments">;; get resulting image semgnets</span>
  hiihat_segment_spectra, fid_n, fid_seg, spectra=img_segments, $
                          verbose=self.verbose

  <span class="comments">;; load segment image</span>
  img_seg=envi_get_data(fid=fid_seg, dims=dims, pos=[0])

  <span class="comments">;; if the segmentation produced &lt; # of classes, fail</span>
  test_nseg = n_elements(uniq(img_seg)) gt k

  <span class="comments">;; all segments should be "pure" - consisting of only a single class</span>
  hiihat_seg_purity, img_seg, img_class, purity=purity, verbose=self.verbose
  test_pure = purity eq 1.0

cleanup_segmentation_test:
  <span class="comments">;; clean up</span>
  envi_file_mng, id=fid_n, /remove
  envi_file_mng, id=fid_class, /remove
  envi_file_mng, id=fid_seg, /remove

  <span class="comments">;; assert segmentation tests</span>
  assert, test_nseg, "Segmentation produced less than #classes segments"+img_base     
  assert, test_pure, "Segmentation produced mixed segments"+img_base     
  
  return, 1
end

<a id="test_hiihat_6d_synthetic_ut::test_nfindr:source"></a>function test_hiihat_6d_synthetic_ut::test_nfindr
<span class="comments">;+</span>
<span class="comments">; Tests the N-FINDR algorithm on noisy 8-class synthetic data. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Test the hiihat_get_superpixel_endmembers function using the</span>
<span class="comments">;   N-FINDR algorithm using noisy 8-class synthetic data. First</span>
<span class="comments">;   attempts to detect the exact class means using the known class map</span>
<span class="comments">;   as the input to the superpixel endmember detection routine. These</span>
<span class="comments">;   endmembers should match the class means exactly. Next</span>
<span class="comments">;   attempts to detect superpixel endmembers from a new</span>
<span class="comments">;   oversegmentation of the image data. These endmembers should be</span>
<span class="comments">;   within the known noise variance of the class means. N-FINDR can</span>
<span class="comments">;   only extract num_bands-1 endmembers, but those endmembers should</span>
<span class="comments">;   each be representatives from a different class.</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Jan 3, 2011 (BDB): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
  compile_opt strictarr

  dist_metric="euclidean"

  <span class="comments">;; assume test failure</span>
  test_nfindr=0
  test_nfindr_seg=0
  test_nfindr_endm=0
  test_nfindr_endm_seg=0

  <span class="comments">;; remove old rois</span>
  envi_delete_rois, /all  

  <span class="comments">;; load noisy 8-class synthetic data</span>
  k = 8
  kstr = string(k,format='(%"%d")')
  nstr = "-n_m0v5"
  img_base=kstr+'class_noisy'+self.sep+''+kstr+'class-layout1'
  img_npath = self.datadir+img_base+nstr+'.img'
  img_classpath=self.datadir+img_base+'.map.img'

  <span class="comments">;; define output temporary file paths</span>
  out_name_roi=self.datadir+img_base+'_endm.roi'
  out_name_sli=self.datadir+img_base+'_endm.sli'
  out_name_slh=self.datadir+img_base+'_endm.sli.hdr'
  out_name_txt=self.datadir+img_base+'_endm.txt'
  
  <span class="comments">;; delete temporary files if they exist</span>
  file_delete, out_name_sli, out_name_slh, /quiet
  file_delete, out_name_roi, out_name_txt, /quiet

  <span class="comments">;; load noisy image and class map</span>
  envi_open_file, img_npath, r_fid=fid_n 
  envi_open_file, img_classpath, r_fid=fid_class

  envi_file_query, fid_n, dims=dims, ns=ns, nl=nl, nb=nb

  <span class="comments">;; assume "perfect" segmentation; use known class partitions</span>
  img_class=envi_get_data(fid=fid_class, dims=dims, pos=[0])

  ignore_seg = 1 <span class="comments">;; use the segmentation for superpixel endmember extraction</span>

  <span class="comments">;; we wish to detect the class means</span>
  hiihat_segment_spectra, fid_n, fid_class, spectra=class_means, $
                          verbose=self.verbose


  n_endmembers=5 <span class="comments">;; N-FINDR can only extract nb-1 endmembers</span>

  <span class="comments">;; first extract endmembers matching the class means</span>
  hiihat_get_superpixel_endmembers, fid_n, seg_fid=fid_class, $
                                    n_endmembers=n_endmembers, $ <span class="comments">;number of endmembers to request</span>
                                    out_name_roi=out_name_roi, $ <span class="comments">;roi endmember file outpath</span>
                                    out_name_sli=out_name_sli, $ <span class="comments">; name of the sli file to generate for endmember spectra</span>
                                    out_name_txt=out_name_txt, $ <span class="comments">; name of the sli file to generate for endmember spectra</span>
                                    r_fid=endmember_fid_nfindr, $ <span class="comments">; return fid for the endmember spectra</span>
                                    abund_r_fid=nfindr_abund_r_fid, $
                                    coalesce_threshold=coalesce_threshold, $ <span class="comments">;                                              </span>
                                    use_nfindr=1, $ <span class="comments">; Use the NFINDR algorithm (custom HIIHAT implementation)</span>
                                    ignore_segmentation=0, $ <span class="comments">; Use entire image unsegmented (for comparison)                                              </span>
                                    seed=seed, $ <span class="comments">; if used, the random seed for the NFINDR algorithm (optional)</span>
                                    in_memory=1, $                                                
                                    verbose=self.verbose

  <span class="comments">;; make sure the output fid was set (this checks the above function</span>
  <span class="comments">;; returned properly)</span>
  test_nfindr=keyword_set(endmember_fid_nfindr)
  if not test_nfindr then goto, cleanup_test_nfindr

  <span class="comments">;; get the endmembers</span>
  envi_file_query, endmember_fid_nfindr, ns=ns, nb=nb, nl=nl, dims=dims
  endmembers_nfindr=transpose(envi_get_data(fid=endmember_fid_nfindr, dims=dims, pos=0))

  <span class="comments">;; these should match the class means exactly</span>
  dmtx = hiihat_distance_matrix(dist_metric, class_means, endmembers_nfindr)
  test_nfindr_endm = total(min(dmtx,dimension=1)) eq 0.0
  

  <span class="comments">;; now extract endmembers from a segmentation</span>
  min_size=1
  C = 100
  hiihat_segment_felzenszwalb, fid_n, C, min_size, dist_metric, $
                               r_fid=fid_seg, verbose=self.verbose, /in_memory, $
                               permute_segments=self.permute_segments
 
  <span class="comments">;; remove endmember/abund fids if they exist</span>
  if keyword_set(endmember_fid_nfindr) then $
    envi_file_mng, id=endmember_fid_nfindr, /remove
  if keyword_set(nfindr_abund_r_fid) then $
    envi_file_mng, id=nfindr_abund_r_fid, /remove

  hiihat_get_superpixel_endmembers, fid_n, seg_fid=fid_seg, $
                                    n_endmembers=n_endmembers, $ <span class="comments">;number of endmembers to request</span>
                                    out_name_roi=out_name_roi, $ <span class="comments">;roi endmember file outpath</span>
                                    out_name_sli=out_name_sli, $ <span class="comments">; name of the sli file to generate for endmember spectra</span>
                                    out_name_txt=out_name_txt, $ <span class="comments">; name of the sli file to generate for endmember spectra</span>
                                    r_fid=endmember_fid_nfindr, $ <span class="comments">; return fid for the endmember spectra</span>
                                    abund_r_fid=nfindr_abund_r_fid, $
                                    coalesce_threshold=coalesce_threshold, $ <span class="comments">;                                              </span>
                                    use_nfindr=1, $ <span class="comments">; Use the NFINDR algorithm (custom HIIHAT implementation)</span>
                                    ignore_segmentation=0, $ <span class="comments">; Use entire image unsegmented (for comparison)                                              </span>
                                    seed=seed, $ <span class="comments">; if used, the random seed for the NFINDR algorithm (optional)</span>
                                    in_memory=1, $                                                
                                    verbose=self.verbose

  <span class="comments">;; make sure the output fid was set (this checks the above function</span>
  <span class="comments">;; returned properly)</span>
  test_nfindr_seg=keyword_set(endmember_fid_nfindr)
  if not test_nfindr_seg then goto, cleanup_test_nfindr

  <span class="comments">;; get the endmembers</span>
  envi_file_query, endmember_fid_nfindr, ns=ns, nb=nb, nl=nl, dims=dims
  endmembers_nfindr=transpose(envi_get_data(fid=endmember_fid_nfindr, dims=dims, pos=0))

  <span class="comments">;; make sure they're close enough to the true class means</span>
  <span class="comments">;; (assuming euclidean distance)</span>
  scalef = 10000.0 <span class="comments">;; 6d-syn data scaled by 10k </span>
  dmtx = hiihat_distance_matrix(dist_metric, class_means / scalef, endmembers_nfindr / scalef)  
  test_nfindr_seg_endm = (total(min(dmtx,dimension=1)) le (n_endmembers*12.0))

  if self.verbose then begin
     print, "Class means"
     print, class_means
     
     print, "NFINDR Endmembers"
     print, endmembers_nfindr
     
     print, "Distance Matrix"
     print, dmtx
  endif

cleanup_test_nfindr:

  envi_delete_rois, /all

  envi_file_mng, id=fid_n, /remove
  envi_file_mng, id=fid_class, /remove
  envi_file_mng, id=fid_seg, /remove

  if keyword_set(endmember_fid_nfindr) then $
    envi_file_mng, id=endmember_fid_nfindr, /remove
  if keyword_set(nfindr_abund_r_fid) then $
    envi_file_mng, id=nfindr_abund_r_fid, /remove

  <span class="comments">;;delete temporary files if they exist</span>
  file_delete, out_name_sli, out_name_slh, /quiet
  file_delete, out_name_roi, out_name_txt, /quiet
  
  <span class="comments">;; assert tests</span>
  assert, test_nfindr, "N-FINDR endmember detection failed"
  assert, test_nfindr_seg, "N-FINDR superpixel endmember detection failed"
  assert, test_nfindr_endm, "N-FINDR endmembers do not match class means"
  assert, test_nfindr_seg_endm, "N-FINDR superpixel endmembers too far from class means"

  return, 1
 end


<a id="test_hiihat_6d_synthetic_ut::test_smacc:source"></a>function test_hiihat_6d_synthetic_ut::test_smacc
<span class="comments">;+</span>
<span class="comments">; Tests the SMACC algorithm on noisy 8-class synthetic data. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Test the hiihat_get_superpixel_endmembers function using the</span>
<span class="comments">;   SMACC algorithm using noisy 8-class synthetic data. First</span>
<span class="comments">;   attempts to detect the exact class means using the known class map</span>
<span class="comments">;   as the input to the superpixel endmember detection routine. These</span>
<span class="comments">;   endmembers should match the class means exactly. Next</span>
<span class="comments">;   attempts to detect superpixel endmembers from a new</span>
<span class="comments">;   oversegmentation of the image data. These endmembers should be</span>
<span class="comments">;   within the known noise variance of the class means. SMACC can</span>
<span class="comments">;   extract an arbitrary number of endmembers, so we should be able to</span>
<span class="comments">;   retrieve all 8 class means and select pixel endmembers that are</span>
<span class="comments">;   near each of those 8 means. </span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Jan 3, 2011 (BDB): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
  compile_opt strictarr

  dist_metric="euclidean"

  <span class="comments">;; assume test failure</span>
  test_smacc = 0
  test_smacc_endm = 0
  test_smacc_seg = 0
  test_smacc_endm_seg = 0

  envi_delete_rois, /all  

  <span class="comments">;; load noisy 8-class synthetic data</span>
  k = 8
  kstr = string(k,format='(%"%d")')
  nstr = "-n_m0v5"
  img_base=kstr+'class_noisy'+self.sep+''+kstr+'class-layout1'
  img_npath = self.datadir+img_base+nstr+'.img'
  img_classpath=self.datadir+img_base+'.map.img'

  <span class="comments">;; set up temp filenames</span>
  out_name_roi=self.datadir+img_base+'_endm.roi'
  out_name_sli=self.datadir+img_base+'_endm.sli'
  out_name_slh=self.datadir+img_base+'_endm.sli.hdr'
  out_name_txt=self.datadir+img_base+'_endm.txt'
  
  <span class="comments">;; delete temporary files if they exist</span>
  file_delete, out_name_sli, out_name_slh, /quiet
  file_delete, out_name_roi, out_name_txt, /quiet

  <span class="comments">;; open the noisy image and class map</span>
  envi_open_file, img_npath, r_fid=fid_n 
  envi_open_file, img_classpath, r_fid=fid_class

  envi_file_query, fid_n, dims=dims, ns=ns, nl=nl, nb=nb

  <span class="comments">;; assume "perfect" segmentation; use known class partitions</span>
  img_class=envi_get_data(fid=fid_class, dims=dims, pos=[0])

  
  <span class="comments">;; first, we wish to detect the class means</span>
  hiihat_segment_spectra, fid_n, fid_class, spectra=class_means, $
                          verbose=self.verbose

  n_endmembers = 8 <span class="comments">;; SMACC can get all eight class endmembers</span>
  hiihat_get_superpixel_endmembers, fid_n, seg_fid=fid_class, $
                                    n_endmembers=n_endmembers, $ <span class="comments">;number of endmembers to request</span>
                                    out_name_roi=out_name_roi, $ <span class="comments">;roi endmember file outpath</span>
                                    out_name_sli=out_name_sli, $ <span class="comments">; name of the sli file to generate for endmember spectra</span>
                                    r_fid=endmember_fid_smacc, $ <span class="comments">; return fid for the endmember spectra</span>
                                    abund_r_fid=smacc_abund_r_fid, $
                                    coalesce_threshold=coalesce_threshold, $ <span class="comments">;                                              </span>
                                    use_nfindr=0, $ <span class="comments">; Do not Use the NFINDR algorithm (custom HIIHAT implementation)</span>
                                    ignore_segmentation=0, $ <span class="comments">; Use entire image unsegmented (for comparison)                                              </span>
                                    seed=seed, $ <span class="comments">; if used, the random seed for the NFINDR algorithm (optional)</span>
                                    in_memory=1, $
                                    verbose=self.verbose

  <span class="comments">;; make sure that the endmember detection routine completed</span>
  test_smacc=keyword_set(endmember_fid_smacc)
  if test_smacc then begin <span class="comments">;; if this test succeeds, check endmembers</span>
     envi_file_query, endmember_fid_smacc, ns=ns, nb=nb, nl=nl, dims=dims
     endmembers_smacc=transpose(envi_get_data(fid=endmember_fid_smacc, dims=dims, pos=0))
     
     <span class="comments">;; these should equal the class means</span>
     dmtx = hiihat_distance_matrix(dist_metric, class_means, endmembers_smacc)
     test_smacc_endm = (total(min(dmtx,dimension=1)) eq 0.0)

     if keyword_set(endmember_fid_smacc) then $
        envi_file_mng, id=endmember_fid_smacc, /remove
     if keyword_set(smacc_abund_r_fid) then $
        envi_file_mng, id=smacc_abund_r_fid, /remove

  endif

  <span class="comments">;; now do superpixel endmember detection</span>
  min_size=1
  C = 1
  hiihat_segment_felzenszwalb, fid_n, C, min_size, dist_metric, $
                               r_fid=fid_seg, verbose=self.verbose, /in_memory, $
                               permute_segments=self.permute_segments

  hiihat_get_superpixel_endmembers, fid_n, seg_fid=fid_seg, $
                                    n_endmembers=n_endmembers, $ <span class="comments">;number of endmembers to request</span>
                                    out_name_roi=out_name_roi, $ <span class="comments">;roi endmember file outpath</span>
                                    out_name_sli=out_name_sli, $ <span class="comments">; name of the sli file to generate for endmember spectra</span>
                                    r_fid=endmember_fid_smacc, $ <span class="comments">; return fid for the endmember spectra</span>
                                    abund_r_fid=smacc_abund_r_fid, $
                                    coalesce_threshold=coalesce_threshold, $ <span class="comments">;                                              </span>
                                    use_nfindr=0, $ <span class="comments">; Do not Use the NFINDR algorithm (custom HIIHAT implementation)</span>
                                    ignore_segmentation=0, $ <span class="comments">; Use entire image unsegmented (for comparison)                                              </span>
                                    seed=seed, $ <span class="comments">; if used, the random seed for the NFINDR algorithm (optional)</span>
                                    in_memory=1, $
                                    verbose=self.verbose
 
  <span class="comments">;; make sure that the endmember detection routine completed</span>
  test_smacc_seg=keyword_set(endmember_fid_smacc)
  if test_smacc_seg then begin
     <span class="comments">;; make sure they're close enough to the true class means</span>
     <span class="comments">;; (assuming euclidean distance)</span>
     scalef = 10000.0
     dmtx = hiihat_distance_matrix(dist_metric, class_means / scalef, endmembers_smacc / scalef)
     test_smacc_endm_seg = (total(min(dmtx,dimension=1)) le (n_endmembers*12.0))

     if self.verbose then begin
        print, "Class means"
        print, class_means
        
        print, "SMACC Endmembers"
        print, endmembers_smacc
        
        print, "Distance Matrix"
        print, dmtx
     endif
  endif

cleanup_test_smacc:
  <span class="comments">;; remove old rois</span>
  envi_delete_rois, /all

  <span class="comments">;; close files</span>
  envi_file_mng, id=fid_n, /remove
  envi_file_mng, id=fid_class, /remove
  envi_file_mng, id=fid_seg, /remove

  if keyword_set(endmember_fid_smacc) then $
     envi_file_mng, id=endmember_fid_smacc, /remove
  if keyword_set(smacc_abund_r_fid) then $
     envi_file_mng, id=smacc_abund_r_fid, /remove

  <span class="comments">;; delete temporary files if they exist</span>
  file_delete, out_name_sli, out_name_slh, /quiet
  file_delete, out_name_roi, out_name_txt, /quiet

  assert, test_smacc, "SMACC endmember detection failed"
  assert, test_smacc_endm, "SMACC endmembers do not match class means"
  assert, test_smacc_seg, "SMACC superpixel endmember detection failed"
  assert, test_smacc_endm_seg, "SMACC superpixel endmembers too far from class means"

  return, 1
 end
</code>
    </div>
  </body>
</html>