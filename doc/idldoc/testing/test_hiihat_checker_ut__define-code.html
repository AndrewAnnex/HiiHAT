<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.3 on Wed Sep 14 19:26:31 2011 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>test_hiihat_checker_ut__define.pro (HiiHAT)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="test_hiihat_checker_ut__define.pro (HiiHAT)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="test_hiihat_checker_ut__define:source"></a>pro test_hiihat_checker_ut__define
<span class="comments">;+</span>
<span class="comments">; Unit test entry point definition for checkerboard image.</span>
<span class="comments">; Initializes MGTestCase structure for MGUnit unit test. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Dec 10, 2010 (BDB): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Examples:</span>
<span class="comments">;   This unit test can be run with the following command:</span>
<span class="comments">;</span>
<span class="comments">;   mgunit, 'test_hiihat_checker_ut'</span>
<span class="comments">;</span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2010, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
  compile_opt strictarr
  
  define = { test_hiihat_checker_ut, $
             datadir:'', tmpdir:'', seed:0, verbose:0, debug:0, sep:'',$
             c:0.0, dist_metric:'', coalesce_threshold:0, permute_segments:0, $
             nl:[0.0], varl:[0.0], kl:[0,0], sql:[0], $
             inherits MGTestCase } 
end

<a id="test_hiihat_checker_ut::test_0_init:source"></a>function test_hiihat_checker_ut::test_0_init
<span class="comments">;+</span>
<span class="comments">; Initialization test file for checkerboard segmentation and endmember</span>
<span class="comments">; detection unit tests. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Initializes parameters used by the checkerboard unit tests and</span>
<span class="comments">;   verifies that the directory containing the data is</span>
<span class="comments">;   accessible. This test is run before any other checkerboard</span>
<span class="comments">;   unit tests are executed. </span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Dec 10, 2010 (BDB): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2010, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
  hh_path = hiihat_get_config_parm('hiihat_path')
  assert, file_test(hh_path), "HiiHAT directory missing"
  self.sep = path_sep()
  self.datadir = hh_path+'data'+self.sep+'checker'+self.sep
  assert, file_test(self.datadir), "Data directory missing"
  self.verbose = 1
  self.tmpdir = getenv("IDL_TMPDIR")
  self.seed = 1
  self.c = 1.0
  self.dist_metric = 'euclidean_sq'
  self.coalesce_threshold = 0 <span class="comments">;; SMACC coalesce threshold</span>
  self.nl = [3] <span class="comments">;; number of lines in checker file</span>
  self.varl = [5.0] <span class="comments">;; noise variance</span>
  self.kl = [3,9] <span class="comments">;; number of checker classes</span>
  self.sql = [20] <span class="comments">;; checker square size</span>
  self.permute_segments = 0
  return, 1
end


<a id="test_hiihat_checker_ut::test_segmentation:source"></a>function test_hiihat_checker_ut::test_segmentation
<span class="comments">;+</span>
<span class="comments">; Tests segmentation functions on 3 and 9 class noisy checkerboard images.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Tests the Felzenswalb segmentation algorithm on 3 and 9 class</span>
<span class="comments">;   checkerboard noisy/noiseless images. Both cases should produce segmentations</span>
<span class="comments">;   equivalent to the given class map with the provided</span>
<span class="comments">;   parameters. The first test assures that with a min_size parameter</span>
<span class="comments">;   much smaller than the smallest class size (in pixels), the correct</span>
<span class="comments">;   segmentation is still produced with noiseless data. The second</span>
<span class="comments">;   test performs the same segmentation on noisy data, assuring that</span>
<span class="comments">;   all segments are "pure" with respect to the class map (a pure</span>
<span class="comments">;   segment consists of pixels from only one class). The final</span>
<span class="comments">;   test assures that the correct segmentation is produced when the</span>
<span class="comments">;   min_size is set to the minimum known class size. </span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Dec 10, 2010 (BDB): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2010, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
  compile_opt strictarr

  for ni=0, n_elements(self.nl)-1 do begin
     nstr=string(self.nl[ni],format='(%"%d")')
     for si=0, n_elements(self.sql)-1 do begin
        sqstr=string(self.sql[si],format='(%"%d")')
        for ki=0, n_elements(self.kl)-1 do begin
           k=self.kl[ki]
           kstr=string(k,format='(%"%d")')
           for vi=0, n_elements(self.varl)-1 do begin
              var=self.varl[vi]
              varstr=string(var,format='(%"%0.3f")')   
        
              <span class="comments">;; assume failure for tests </span>
              test_join=0
              test_pure=0
              test_minsize=0

              <span class="comments">;; load the requisite test files</span>
              img_base='checker'+nstr+'x'+nstr+'_sq'+sqstr+'_d3_k'+kstr
              img_path=self.datadir+img_base+'.img'
              img_npath=self.datadir+img_base+'_n'+varstr+'.img'
              img_classpath=self.datadir+img_base+'_class.img'

              envi_open_file, img_path, r_fid=fid 
              envi_open_file, img_npath, r_fid=fid_n 
              envi_open_file, img_classpath, r_fid=fid_class

              <span class="comments">;; get file dimensions </span>
              envi_file_query, fid, dims=dims, ns=ns, nl=nl, nb=nb

              <span class="comments">;; load the class map</span>
              img_class=envi_get_data(fid=fid_class, dims=dims, pos=[0])

              <span class="comments">;; check simple joins on noiseless data</span>
              <span class="comments">;; This should not merge any pixels from dissimilar classes and </span>
              <span class="comments">;; should produce segments of the same size as the defined classes</span>
              min_size=2
              hiihat_segment_felzenszwalb, fid, self.c, min_size, self.dist_metric, $
                                           r_fid=seg_fid, verbose=self.verbose, /in_memory, $
                                           permute_segments=self.permute_segments

              <span class="comments">;; get the resulting segmentation map</span>
              segments=envi_get_data(fid=seg_fid, dims=dims, pos=[0]) 

              <span class="comments">;; the segmentation should be the same as the class map</span>
              test_join=(total(img_class-segments) eq 0)
              envi_file_mng, id=seg_fid, /remove 

              <span class="comments">;; now try on noisy data</span>
              hiihat_segment_felzenszwalb, fid_n, self.c, min_size, self.dist_metric, $
                                           r_fid=seg_fid, verbose=self.verbose, /in_memory, $
                                           permute_segments=self.permute_segments

              <span class="comments">;; the segmentation should consist of only pure pixels</span>
              hiihat_seg_purity, seg_fid, fid_class, purity=purity, verbose=self.verbose
              test_pure = purity eq 1.0

              envi_file_mng, id=seg_fid, /remove 

              <span class="comments">;; check minsize on noisy data. </span>
              <span class="comments">;; This forces the segmentation algorithm to join all regions </span>
              <span class="comments">;; up to the maximum size for each class, so each segment should </span>
              <span class="comments">;; consist of one class</span>
              min_size=((ns*nl)/k-1) <span class="comments">;; known size for each class</span>
              hiihat_segment_felzenszwalb, fid_n, self.c, min_size, $
                                           self.dist_metric, r_fid=seg_fid, $
                                           verbose=self.verbose, /in_memory, $
                                           permute_segments=self.permute_segments

              <span class="comments">;; get the resulting segmentation map</span>
              segments=envi_get_data(fid=seg_fid, dims=dims, pos=[0])               

              <span class="comments">;; this should also be the same as the class map</span>
              test_minsize = (total(img_class-segments) eq 0)

cleanup_segmentation_test:
              <span class="comments">;; clean up</span>
              envi_file_mng, id=fid, /remove
              envi_file_mng, id=fid_n, /remove
              envi_file_mng, id=fid_class, /remove
              envi_file_mng, id=seg_fid, /remove


              assert, test_join, "Joins: segmentation does not match class map: "+img_base     
              assert, test_minsize, "Minsize: segmentation does not match class map: "+img_base     

           endfor
        endfor
     endfor
  endfor

  return, 1
end

<a id="test_hiihat_checker_ut::test_endmember_detection:source"></a>function test_hiihat_checker_ut::test_endmember_detection
<span class="comments">;+</span>
<span class="comments">; Tests endmember detection functions on 3 and 9 class noisy checkerboard images.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Tests both the SMACC and N-FINDR endmember detection algorithms on</span>
<span class="comments">;   the checkerboard images. Both algorithms use the known class map</span>
<span class="comments">;   as the superpixels, and attempt to retrieve the known number of</span>
<span class="comments">;   classes for each image. SMACC will succeed and the endmembers</span>
<span class="comments">;   should match the class means. N-FINDR should fail gracefully on</span>
<span class="comments">;   all inputs since it can only extract (2,num_bands-1] endmembers. </span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Dec 10, 2010 (BDB): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2010, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
  compile_opt strictarr

  for ni=0, n_elements(self.nl)-1 do begin
     nstr=string(self.nl[ni],format='(%"%d")')
     for si=0, n_elements(self.sql)-1 do begin
        sqstr=string(self.sql[si],format='(%"%d")')
        for ki=0, n_elements(self.kl)-1 do begin
           k=self.kl[ki]
           kstr=string(k,format='(%"%d")')
           for vi=0, n_elements(self.varl)-1 do begin
              var=self.varl[vi]
              varstr=string(var,format='(%"%0.3f")')        

              <span class="comments">;; remove old rois</span>
              envi_delete_rois, /all

              <span class="comments">;; assume test failure</span>
              test_nfindr=0
              test_smacc=0
              test_smacc_endm=0

              <span class="comments">;; load the requisite test files</span>
              img_base='checker'+nstr+'x'+nstr+'_sq'+sqstr+'_d3_k'+kstr
              img_path=self.datadir+img_base+'.img'
              img_npath=self.datadir+img_base+'_n'+varstr+'.img'
              img_classpath=self.datadir+img_base+'_class.img'

              out_name_roi=self.datadir+img_base+'_endm.roi'
              out_name_sli=self.datadir+img_base+'_endm.sli'
              out_name_slh=self.datadir+img_base+'_endm.sli.hdr'
              out_name_txt=self.datadir+img_base+'_endm.txt'
             
              <span class="comments">;; delete temporary files if they exist</span>
              file_delete, out_name_sli, out_name_slh, /quiet
              file_delete, out_name_roi, out_name_txt, /quiet

              <span class="comments">;; open the image</span>
              envi_open_file, img_path, r_fid=fid 
              envi_open_file, img_npath, r_fid=fid_n 
              envi_open_file, img_classpath, r_fid=fid_class

              envi_file_query, fid, dims=dims, ns=ns, nl=nl, nb=nb

              <span class="comments">;; assume "perfect" segmentation; use known class partitions</span>
              img_class=envi_get_data(fid=fid_class, dims=dims, pos=[0])
             
              <span class="comments">;; first we wish to detect the class means with SMACC</span>
              hiihat_segment_spectra, fid_n, fid_class, spectra=class_means, $
                                      verbose=self.verbose

              hiihat_get_superpixel_endmembers, fid_n, seg_fid=fid_class, $
                                                n_endmembers=k, $ <span class="comments">;number of endmembers to request</span>
                                                out_name_roi=out_name_roi, $ <span class="comments">;roi endmember file outpath</span>
                                                out_name_sli=out_name_sli, $ <span class="comments">; name of the sli file to generate for endmember spectra</span>
                                                r_fid=endmember_fid_smacc, $ <span class="comments">; return fid for the endmember spectra</span>
                                                abund_r_fid=smacc_abund_r_fid, $
                                                coalesce_threshold=coalesce_threshold, $ <span class="comments">;                                              </span>
                                                use_nfindr=0, $ <span class="comments">; Do not Use the NFINDR algorithm (custom HIIHAT implementation)</span>
                                                ignore_segmentation=0, $ <span class="comments">; Use entire image unsegmented (for comparison)                                              </span>
                                                seed=self.seed, $ <span class="comments">; if used, the random seed for the NFINDR algorithm (optional)</span>
                                                in_memory=1, $
                                                verbose=self.verbose

              test_smacc=keyword_set(endmember_fid_smacc)              
              if  test_smacc then begin <span class="comments">;; if this test succeeds, check endmembers</span>
                 envi_file_query, endmember_fid_smacc, ns=ns, nb=nb, nl=nl, dims=dims
                 endmembers_smacc=transpose(envi_get_data(fid=endmember_fid_smacc, dims=dims, pos=0))
                 test_smacc_endm = total(endmembers_smacc[sort(endmembers_smacc)] - $
                                         class_means[sort(class_means)]) eq 0
              endif

              <span class="comments">;; try N-FINDR (and fail due to nb=3 and k>nb-1)</span>
              hiihat_get_superpixel_endmembers, fid_n, seg_fid=fid_class, $
                                                n_endmembers=k, $ <span class="comments">;number of endmembers to request</span>
                                                out_name_roi=out_name_roi, $ <span class="comments">;roi endmember file outpath</span>
                                                out_name_sli=out_name_sli, $ <span class="comments">; name of the sli file to generate for endmember spectra</span>
                                                r_fid=endmember_fid_nfindr, $ <span class="comments">; return fid for the endmember spectra</span>
                                                abund_r_fid=nfindr_abund_r_fid, $
                                                coalesce_threshold=coalesce_threshold, $ <span class="comments">;                                              </span>
                                                use_nfindr=1, $ <span class="comments">; Use the NFINDR algorithm (custom HIIHAT implementation)</span>
                                                ignore_segmentation=0, $ <span class="comments">; Use entire image unsegmented (for comparison)                                              </span>
                                                seed=self.seed, $ <span class="comments">; if used, the random seed for the NFINDR algorithm (optional)</span>
                                                in_memory=1, $                                                
                                                verbose=self.verbose

              <span class="comments">;; expected failure - N-FINDR can only extract (2,nb-1]</span>
              <span class="comments">;;                    endmembers, so this should fail</span>
              <span class="comments">;;                    gracefully</span>
              test_nfindr=(keyword_set(endmember_fid_nfindr) eq 0)

cleanup_endmember_test:
              <span class="comments">;; remove old rois</span>
              envi_delete_rois, /all

              <span class="comments">;; get rid of old files</span>
              envi_file_mng, id=fid, /remove
              envi_file_mng, id=fid_n, /remove
              envi_file_mng, id=fid_class, /remove
              if keyword_set(endmember_fid_smacc) then $
                 envi_file_mng, id=endmember_fid_smacc, /remove
              if keyword_set(endmember_fid_nfindr) then $
                 envi_file_mng, id=endmember_fid_nfindr, /remove
              if keyword_set(smacc_abund_r_fid) then $
                 envi_file_mng, id=smacc_abund_r_fid, /remove
              if keyword_set(nfindr_abund_r_fid) then $
                 envi_file_mng, id=nfindr_abund_r_fid, /remove
              
              assert, test_smacc, "SMACC endmember detection failed"
              assert, test_smacc_endm, "SMACC endmembers do not match class means"
              assert, test_nfindr, "N-FINDR endmember detection did not fail gracefully"

           endfor
        endfor
     endfor
  endfor             
 
  return, 1
 end


<a id="test_hiihat_checker_ut::test_neutral_region:source"></a>function test_hiihat_checker_ut::test_neutral_region
<span class="comments">;+</span>
<span class="comments">; Tests neutral region on 3x3 noisy grid.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   testing</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Tests the neutral region finder on a 3x3 macrogrid with artificial</span>
<span class="comments">;   noise. Determines whether the found neutral region detected is the</span>
<span class="comments">;   lower-left grid (correct answer) regardless of the neutral region</span>
<span class="comments">;   precise shape determined. </span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Feb 16, 2011 (LM): Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Author: Lukas Mandrake</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
  compile_opt strictarr

  <span class="comments">;; remove old rois</span>
  envi_delete_rois, /all

  <span class="comments">;; assume failure for tests </span>
  test_segmentation            = 0
  test_neutral_region_location = 0
  test_neutral_region_size     = 0

  <span class="comments">;; load the requisite test files</span>
  spectest=self.datadir+'neutral_spectrum_test.temp.sli'
  img_test=self.datadir+'checker3x3_sq20_d3_k9_n5.000.img'

  <span class="comments">;; remove old temp files</span>
  file_delete, spectest, /quiet

  envi_open_file, img_test, r_fid=fid 
  envi_file_query, fid, dims=dims, ns=ns, nl=nl, nb=nb

  <span class="comments">;; We will now perform a "standard" segmentation on this</span>
  <span class="comments">;; test data. The segments will grossly oversegment the</span>
  <span class="comments">;; noisy grid image. </span>
  min_size=20
  c=0.01
  hiihat_segment_felzenszwalb, fid, c, min_size, $
    "euclidean_sq", r_fid=seg_fid, $
    verbose=self.verbose, /in_memory, $
    permute_segments=0

  <span class="comments">;Generate and test segmentation</span>
  segments=envi_get_data(fid=seg_fid, dims=dims, pos=[0])
  test_segmentation = (max(segments) gt 2) and (min(segments) ge 0) 
  assert, test_segmentation           , "Neutral Region: segmentation was not generated: "            +img_test     

  <span class="comments">;Generate neutral region ROI</span>
  hiihat_get_neutral_region, img_fid=fid, seg_fid=seg_fid, $
    roi_out_id = roi_out_id, spectrum_out_filename=spectest,$
    coalesce_threshold=coalesce_threshold, verbose=self.verbose

  <span class="comments">;Convert to x,y points</span>
  roi_contents = envi_get_roi(roi_out_id)
  ypts = floor(roi_contents  /  ns)
  xpts =       roi_contents mod ns
  
  <span class="comments">;Test size of neutral region</span>
  test_neutral_region_size = (size(xpts,/dimensions) gt 5) and (size(xpts,/dimensions) lt 100)
  assert, test_neutral_region_size    , "Neutral Region: neutral region was inappropriately sized: "  +img_test     

                                <span class="comments">;Test location of neutral region</span>
                                <span class="comments">;All of ROI should be contained in the</span>
                                <span class="comments">;lower-left square of the image</span>
  test_neutral_region_location = (max(xpts) le 19) and (min(xpts) ge 0) and (max(ypts) le 59) and (min(ypts) ge 40)
  assert, test_neutral_region_location, "Neutral Region: neutral region was not in correct location: "+img_test     

cleanup_neutral_region_test:
  <span class="comments">;; clean up</span>
  envi_open_file, spectest, r_fid=fidspec 
  envi_file_mng, id=    fid, /remove
  envi_file_mng, id=seg_fid, /delete, /remove
  envi_file_mng, id=fidspec, /delete, /remove
  envi_delete_rois, roi_out_id

  return, 1
end
</code>
    </div>
  </body>
</html>