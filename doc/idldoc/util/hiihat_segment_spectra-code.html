<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.3 on Wed Sep 14 19:26:35 2011 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hiihat_segment_spectra.pro (HiiHAT)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hiihat_segment_spectra.pro (HiiHAT)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; Calculates mean signatures for a given image using its corresponding</span>
<span class="comments">; segmentation image, optionally returns the "mean image" populated with</span>
<span class="comments">; the calculated segments. Returns the mean spectra of each superpixel segment. </span>
<span class="comments">;  Robust option will tolerate infinities and other nonsense input, returning </span>
<span class="comments">;  a zeroed out spectrum. If user specifies r_fid, then</span>
<span class="comments">;  mean_image_name and r_fid are used to generate a new full image</span>
<span class="comments">;  where each superpixel has its mean spectrum replacing the entire</span>
<span class="comments">;  segment area. If /return_image is not set, mean_image_name and r_fid</span>
<span class="comments">;  are ignored. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   util</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   img_fid: in, required, type="fltarr(ns,nl,nb)"</span>
<span class="comments">;     fid of input image data</span>
<span class="comments">;   seg_fid: in, required, type="fltarr(ns,nl)"</span>
<span class="comments">;     fid of segmentation image</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;  spectra: out, required, type="fltarr(nseg, nbands)"</span>
<span class="comments">;  use_dims: in, optional, type=dims</span>
<span class="comments">;    override default dimensions</span>
<span class="comments">;  r_fid: out, optional, type=fix</span>
<span class="comments">;    return file id for output segment mean spectra</span>
<span class="comments">;  mean_image_name: in, optional, type=string</span>
<span class="comments">;    output mean image filename, if unspecified, will compute mean image in memory</span>
<span class="comments">;  mean_fid: out, optional, type=fix</span>
<span class="comments">;    fid of output mean image</span>
<span class="comments">;  variances: out, optional, type="fltarr(nseg,nbands)"</span>
<span class="comments">;    band variances of segment pixels</span>
<span class="comments">;  verbose: in, optional, type="boolean"</span>
<span class="comments">;    enable verbose status messages</span>
<span class="comments">;  return_image: in, optional, type=boolean</span>
<span class="comments">;    return mean image</span>
<span class="comments">;</span>
<span class="comments">; :Pre:</span>
<span class="comments">;   If the "robust_means" parameter is set to 1 in the configuration file, this</span>
<span class="comments">;   procedure will zero out means with zero or infinite band values</span>
<span class="comments">; </span>
<span class="comments">; :Examples:</span>
<span class="comments">;   The following code will return the segments for img_fid/seg_fid along </span>
<span class="comments">;   with the mean image for the data (in memory).</span>
<span class="comments">;</span>
<span class="comments">;   hiihat_segment_spectra, img_fid, seg_fid, spectra=spectra, </span>
<span class="comments">;                         r_fid=r_fid, return_image=1, verbose=1</span>
<span class="comments">; </span>
<span class="comments">; :Author: David Ray Thompson (DRT)</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   2009 (DRT): initially implemented</span>
<span class="comments">;</span>
<span class="comments">;   Dec 13, 2010 (BDB): added docstr</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2009, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="hiihat_segment_spectra:source"></a>pro hiihat_segment_spectra, img_fid, seg_fid, spectra=spectra, $
                            use_dims = use_dims, r_fid = r_fid, $
                            variances=variances, mean_fid=mean_fid, $
                            mean_image_name = mean_image_name, $
                            return_image=return_image, verbose = verbose

  compile_opt IDL2

  debug = hiihat_get_config_parm('debug')
  title='hiihat_segment_spectra'

  if debug then print, "Entering "+title


  if not keyword_set(return_image) then return_image = 0
  <span class="comments">;; exclude pixels with zero or infinity reflectance entries</span>
  
  <span class="comments">;; load the image, correct for use_dims being smaller than whole image</span>
  envi_file_query, img_fid, dims=img_dims, nb = img_nb, bnames = bnames,$
                   ns = img_ns, nl = img_nl, wl = img_wl, fwhm = fwhm , $
                   wavelength_units = wavelength_units, data_type = data_type

  if keyword_set (use_dims) then begin 
     img_ns = use_dims[2]-use_dims[1]+1
     img_nl = use_dims[4]-use_dims[3]+1
     if verbose then print, "Reset segmentation img_ns, img_nl to",img_ns, img_nl
  endif else use_dims = img_dims



  img = fltarr(img_ns*img_nl, img_nb)
  for i=0,img_nb-1 do begin
     band = envi_get_data(fid=img_fid, dims = use_dims, pos = i)
     img[*,i] = band
  endfor    

  <span class="comments">;img = hiihat_load_bands(fid=img_fid, dims = use_dims)</span>

<span class="comments">;    assert, min(finite(img)) eq 1, "HIIHAT_SEGMENT_SPECTRA image file contains non-finite elements"</span>


  if verbose then print, "Loading segmentation"

  envi_file_query, seg_fid, nb=seg_nb, ns=seg_ns, nl=seg_nl, dims=seg_dims
  segments = envi_get_data(fid=seg_fid, dims=seg_dims, pos = [0]) 
  labels = segments[uniq(segments,sort(segments))]   <span class="comments">;; unique segment labels</span>
  labels = labels[sort(labels)]                      <span class="comments">;; FIXME: may be redundant</span>
  n_segments = (size(labels))[1]               <span class="comments">;; length of unique label vector</span>
  spectra = fltarr(n_segments, img_nb)               <span class="comments">; representative spectra</span>
  if verbose then print, n_segments," segments loaded"

  if keyword_set(variances) then variances = fltarr(n_segments,img_nb)

  if return_image then meanimage=fltarr(img_ns,img_nl,img_nb)

  if verbose then print, "Averaging spectra"

  <span class="comments">;; Create the progress bar.</span>
  envi_report_init, "Calculating mean spectra", base=base, /INTERRUPT, title=title 
  envi_report_inc, base, 100

  for i=0, n_segments-1 do begin
     
     if i mod 100 eq 0 then begin
        envi_report_stat, base, (i/float(n_segments)*100), 100, cancel=cancel                                             
        if cancel then goto, cleanup
     endif


     indices = where(segments eq labels[i])
     n_pix = n_elements(indices)
     segment_pixels = img[indices,*]

     <span class="comments">;;if verbose then print, n_pix, ' pixels in segment ', i</span>
     hiihat_get_mean_spectrum, segment_pixels, mean_spectrum=mean_spectrum, $
                               bad_pixels=bad_pixels, zero_pixels=zero_pixels
     
     if bad_pixels gt 0 then print, bad_pixels, " bad pixels found in segment ", i
     if zero_pixels gt 0 then print, zero_pixels, ' zero pixels found in segment ', i


     <span class="comments">;;print, 'ms size', size(mean_spectrum)</span>
     <span class="comments">;;print, "spec size", size(spectra[i,*])</span>
     spectra[i,*] = mean_spectrum

     if keyword_set(variances) then begin
        mean_diff = fltarr(img_nb)
        for i=0, n_pix-1 do mean_diff+=(segment_pixels[i,*]-mean_spectrum)^2
        variances[i,*] = mean_diff/float(n_pix)
     endif
     if return_image then begin
        for t = 0, n_pix-1 do begin
           x = indices[t] mod seg_ns
           y = floor(indices[t] / seg_ns)
           meanimage[x,y,*] = mean_spectrum
        endfor     
     endif
  endfor

  
  envi_report_stat, base, 100, 100, cancel=cancel                                             
  
  if return_image then begin
     if not keyword_set(mean_image_name) then begin <span class="comments">;; in memory</span>
        if verbose then print,"Computing mean image in memory"
        envi_write_envi_file, meanimage, $
                              /in_memory, $
                              bnames = bnames, $
                              data_type = data_type, $
                              dims = use_dims, $
                              nb = img_nb, $
                              nl = seg_nl, $
                              ns = seg_ns, $
                              fwhm = fwhm, $
                              out_name=mean_image_name, $
                              r_fid = mean_fid, $
                              wavelength_units = wavelength_units, $
                              wl = wl




     endif else begin
        if verbose then print,"Writing mean image to ",mean_image_name
        envi_write_envi_file, meanimage, $
                              bnames = bnames, $
                              data_type = data_type, $
                              dims = use_dims, $
                              nb = img_nb, $
                              nl = seg_nl, $
                              ns = seg_ns, $
                              fwhm = fwhm, $
                              out_name=mean_image_name, $
                              r_fid = mean_fid, $
                              wavelength_units = wavelength_units, $
                              wl = wl

        <span class="comments">;;envi_file_mng, id = mean_fid, /remove</span>
        <span class="comments">;;envi_open_file, mean_image_name, r_fid = mean_fid, /no_realize</span>
     endelse
  endif


cleanup:
  envi_report_init, base=base, /finish 
  if debug then print,"Exiting "+title
end


</code>
    </div>
  </body>
</html>