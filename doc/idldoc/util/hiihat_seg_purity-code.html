<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.3 on Wed Sep 14 19:26:34 2011 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hiihat_seg_purity.pro (HiiHAT)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hiihat_seg_purity.pro (HiiHAT)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">;  Calculate the overall and per-segment "purity" with respect to a given class</span>
<span class="comments">;  map. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   util </span>
<span class="comments">; :Params:</span>
<span class="comments">;  seg_map: in, required, type="intarr(ns,nl)"</span>
<span class="comments">;    segmentation map</span>
<span class="comments">;  class_map: in, required, type="intarr(ns,nl)"</span>
<span class="comments">;    labeled class map</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;  ignore_classes: in, optional, type="intarr(n_classes)"</span>
<span class="comments">;    list of class values to ignore (e.g. 0 for background classes)</span>
<span class="comments">;</span>
<span class="comments">;  purity: in, optional, type=float</span>
<span class="comments">;    overall purity of seg_map with respect to class_map    </span>
<span class="comments">;  mixtures: in, optional, type="fltarr(n_segments)"</span>
<span class="comments">;    purity of individual segments with respect to class_map</span>
<span class="comments">;  verbose: in, optional, type=boolean</span>
<span class="comments">;    print verbose output to console</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   Dec 31, 2011 (BDB):  Initial implementation</span>
<span class="comments">;  </span>
<span class="comments">; :Author: Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="hiihat_seg_purity:source"></a>pro hiihat_seg_purity, seg_map, class_map, ignore_classes=ignore_classes, purity=purity, $
                       mixtures=mixtures, img=img, distances=distances, verbose=verbose, A=A

  uniq_seg = seg_map[uniq(seg_map,sort(seg_map))]
  uniq_class = class_map[uniq(class_map,sort(class_map))]
  mixed_seg_count = 0 <span class="comments">;; number of mixed segments</span>
  n_ignored = 0 <span class="comments">;; number of completely ignored segments</span>

  n_ignore = n_elements(ignore_classes)
  n_segments = n_elements(uniq_seg)
  n_classes = n_elements(uniq_class)
  mixtures = fltarr(n_segments)+1.0 <span class="comments">; assume each segment pure </span>
  distances = fltarr(n_segments)-1.0 <span class="comments">; distances of pure segs to class means</span>

  if keyword_set(img) then begin
     if keyword_set(A) then dist_metric = 'mahalanobis' else dist_metric='euclidean'
     nsnl = (size(img))[1]
     nb = (size(img))[2]
     class_means = fltarr(n_classes, nb)
     for i=0,n_classes-1 do begin
        if (where(uniq_class[i] eq ignore_classes))[0] ne -1 then continue

        class_idx = where(class_map eq uniq_class[i])
        class_pix = img[class_idx,*]
        n_pix = n_elements(class_idx)
        if verbose then print, "Calculating class mean for ", n_pix, "pixels"
        class_means[i,*] = total(class_pix,1)/float(n_pix)
     endfor
  endif

  <span class="comments">;; examine each segment to make sure it consists of only a single class</span>
  for i=0, n_segments-1 do begin
     seg_lab = uniq_seg[i]
     seg_idx = where(seg_map eq seg_lab)
     seg_class_labs = class_map[seg_idx] <span class="comments">; class labels within current segment</span>

     <span class="comments">;; filter out ignored class pixels</span>
     for j=0, n_ignore-1 do begin
        ig_class = ignore_classes[j]
        keep_idx = where(seg_class_labs ne ig_class)
        if keep_idx[0] eq -1 then begin 
           <span class="comments">;;all elements ignored, undefine seg_class_labs</span>
           temp=size(temporary(seg_class_labs)) 
        endif else begin
           seg_class_labs = seg_class_labs[keep_idx]
           seg_idx = seg_idx[keep_idx]
        endelse
     end

     <span class="comments">;; check if we ignored all pixels in this segment</span>
     if n_elements(seg_class_labs) eq 0 then begin
        n_ignored += 1
        mixtures[i] = -1
        seg_uniq_classes = [0]
     endif else begin        
        <span class="comments">;; pure segments should consist of a single class</span>
        seg_uniq_classes = seg_class_labs[uniq(seg_class_labs, $
                                               sort(seg_class_labs))]
        n_seg_classes = n_elements(seg_uniq_classes)
        if n_seg_classes ne 1 then begin
           mixtures[i] = float(n_seg_classes)/n_elements(seg_class_labs)
           mixed_seg_count += 1
        end
     endelse

     if mixtures[i] eq 1.0 and keyword_set(img) then begin
        ci = where(uniq_class eq seg_uniq_classes[0])
        seg_mean = total(img[seg_idx,*],1)/float(n_elements(seg_idx))
        distances[i] = hiihat_spec_difference(transpose(seg_mean),$
                                              transpose(class_means[ci,*]),$
                                              dist_metric,M=A)                                                     
     endif
                                                     

     if verbose then begin
        outstr = 'Segment '+string(seg_lab,format='(%"%d")')+' purity: '+string(mixtures[i],format='(%"%0.3f")')+' distance: '+string(distances[i],format='(%"%0.3f")')
        print, outstr, " classes: ", seg_uniq_classes
        print, "unique classes: ", n_elements(uniq_class)
     endif
  end
  
  purity = 1.0-(float(mixed_seg_count)/(n_segments-n_ignored))
  if verbose then print, "Segmentation purity:", purity
end 
</code>
    </div>
  </body>
</html>