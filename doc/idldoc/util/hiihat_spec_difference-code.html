<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.3 on Wed Sep 14 19:26:35 2011 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hiihat_spec_difference.pro (HiiHAT)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hiihat_spec_difference.pro (HiiHAT)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; returns a floating point value representing distance between two spectra</span>
<span class="comments">; :Categories: segmentation</span>
<span class="comments">; :Params:</span>
<span class="comments">;  adata: in, required, type="fltarr(nb)"</span>
<span class="comments">;   first input spectrum</span>
<span class="comments">;  bdata: in, required, type="fltarr(nb)"</span>
<span class="comments">;   second input spectrum</span>
<span class="comments">;  dist_metric: in, required, type=string</span>
<span class="comments">;   distance metric between adata and bdata</span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;  reject_zeros: in, optional, type=boolean</span>
<span class="comments">;   reject zero or infinite spectra</span>
<span class="comments">;  M: in, optional, type="fltarr(nb,nb)" </span>
<span class="comments">;   tranformation matrix for Mahalanobis distance function, if unspecified,</span>
<span class="comments">;   reverts to euclidean distance</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;   2009 (DRT): Initial implementation</span>
<span class="comments">;</span>
<span class="comments">;   Dec 31, 2010 (BDB): docstr added</span>
<span class="comments">;  </span>
<span class="comments">; :Author: David Ray Thompson and Brian D. Bue</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2009, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="hiihat_spec_difference:source"></a>function hiihat_spec_difference, adata, bdata, dist_metric, $
                                 reject_zeros=reject_zeros, M=M
  SMALLEST = 1e-40
  HUGE     = 1e40
  <span class="comments">;; We often don't want to ever merge with any entirely zero spectra (bad</span>
  <span class="comments">;; data) or infinity values, but we do want those strange values to </span>
  <span class="comments">;; cluster together</span>
  
  if keyword_set(reject_zeros) then begin
     tadata = total(adata)
     tbdata = total(bdata)
     if tadata lt SMALLEST and tbdata gt 0.0      then return, HUGE
     if tadata gt 0.0      and tbdata lt SMALLEST then return, HUGE
     if tadata lt SMALLEST and tbdata lt SMALLEST then return, 0.0
     iadata = n_elements(adata) - total(finite(adata))
     ibdata = n_elements(bdata) - total(finite(bdata))
     if iadata gt 0        and ibdata eq 0        then return, HUGE
     if iadata eq 0        and ibdata gt 0        then return, HUGE
     if iadata gt 0        and ibdata gt 0        then return, 0.0
  endif

  if dist_metric eq 'mahalanobis' and not keyword_set(M) then begin
     print, 'Mahalanobis metric requires nb x nb matrix "M." Reverting to Euclidean metric.'
     dist_metric = 'euclidean'
  endif

  case dist_metric of
     <span class="comments">;; Spectral Angle version (we generally don't use this anymore)</span>
     'sad': return, acos(total(adata*bdata)/sqrt(total(adata*adata)*total(bdata*bdata)))
     <span class="comments">;; euclidean distance</span>
     'euclidean': return, sqrt(total((adata-bdata)^2))
     <span class="comments">;; squared absolute difference version (not normalized)</span>
     'euclidean_sq': return, total((adata-bdata)^2)
     <span class="comments">;; euclidean distance of L1-normalized spectra</span>
     'euclidean_n': return, sqrt(total((adata/total(adata) - $
                                        bdata/total(adata))^2))
     'mahalanobis': begin 
        return, sqrt(transpose(adata-bdata) # M # transpose(adata-bdata))
     end
  endcase
end
</code>
    </div>
  </body>
</html>