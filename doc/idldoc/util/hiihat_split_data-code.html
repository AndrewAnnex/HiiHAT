<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.3 on Wed Sep 14 19:26:35 2011 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hiihat_split_data.pro (HiiHAT)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hiihat_split_data.pro (HiiHAT)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+ </span>
<span class="comments">; Utility function for splitting labeled data across multiple folds</span>
<span class="comments">; for cross-validation. If multiple domains are specified, points are</span>
<span class="comments">; sampled sequentially across each domain and indices are returned in</span>
<span class="comments">; order of the domains.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Brian Bue</span>
<span class="comments">;</span>
<span class="comments">; :Categories: </span>
<span class="comments">;  util</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;  labels: in, required, type=intarr(n)</span>
<span class="comments">;    labels for each of the data points</span>
<span class="comments">;  num_folds: in, required, type=fix</span>
<span class="comments">;    number of folds for data splitting</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;  domains: in, optional, type=intarr(n)</span>
<span class="comments">;    domains for each of the data points</span>
<span class="comments">;  verbose: in, optional, type=boolean</span>
<span class="comments">;    print verbose output to console</span>
<span class="comments">;  train_idx: out, required, type=intarr(ntr)</span>
<span class="comments">;    output training indices</span>
<span class="comments">;  test_idx: out, required, type=intarr(nte)</span>
<span class="comments">;    output testing indices</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
<a id="hiihat_split_data:source"></a>pro hiihat_split_data, labels, num_folds, domains=domains, verbose=verbose, $
                       train_idx=train_idx, test_idx=test_idx
  
  if not keyword_set(domains) then domains=intarr(n_elements(labels))+1
  
  ulab = labels[uniq(labels,sort(labels))]
  udom = domains[uniq(domains,sort(domains))]

  k = n_elements(ulab) <span class="comments">;; number of classes</span>
  D = n_elements(udom) <span class="comments">;; number of domains</span>

  <span class="comments">;; re-initialize train/test indices</span>
  if keyword_set(train_idx) then temp=size(temporary(train_idx))
  if keyword_set(test_idx) then temp=size(temporary(test_idx))

  for di=0,D-1 do begin 
     for ki=0,k-1 do begin
        <span class="comments">;; get the number of samples in this domain/class</span>
        labdom_idx = where(labels eq ulab[ki] and domains eq udom[di])
        num_labdom = n_elements(labdom_idx)
        if num_labdom eq 0 then continue
        inds = sort(randomu(seed,num_labdom)*num_labdom)
        <span class="comments">;; select at least 1 training sample, </span>
        num_tr = max([1,num_labdom-long(num_labdom/num_folds)])
        num_te = num_labdom-num_tr

        <span class="comments">;; get at least one test point if possible</span>
        if num_te eq 0 and num_tr gt 1 then begin
           num_tr -= 1
           num_te = 1
        endif
        
        if verbose then $
           print, num_tr, ' train points', num_te, ' test points'

        tr_inds = labdom_idx[inds[0:num_tr-1]]
        if n_elements(train_idx) eq 0 then train_idx = tr_inds else $ 
           train_idx = [train_idx,tr_inds]                 

        if num_te gt 0 then begin
           te_inds = labdom_idx[inds[num_tr:(num_tr+num_te)-1]]           
           if n_elements(test_idx) eq 0 then test_idx = te_inds else $
              test_idx = [test_idx,te_inds]                    
        endif        
     endfor
  endfor
end
</code>
    </div>
  </body>
</html>