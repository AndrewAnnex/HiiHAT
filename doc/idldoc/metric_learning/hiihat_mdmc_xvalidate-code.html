<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.3 on Wed Sep 14 19:26:29 2011 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hiihat_mdmc_xvalidate.pro (HiiHAT)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hiihat_mdmc_xvalidate.pro (HiiHAT)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+ </span>
<span class="comments">; Wrapper to learn optimal regularization parameter lambda \in [0,1]</span>
<span class="comments">; for LDA via cross validation. </span>
<span class="comments">;</span>
<span class="comments">; :Author: Brian Bue</span>
<span class="comments">;</span>
<span class="comments">; :Categories: </span>
<span class="comments">;  metric_learning</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;  data: in, required, type="fltarr(n,nb)"</span>
<span class="comments">;    labeled data to determine transform </span>
<span class="comments">;  labels: in, required, type="intarr(n)"</span>
<span class="comments">;    labels for each of the data points</span>
<span class="comments">;  reg_parms: in, required, type=struct</span>
<span class="comments">;    regularization parameters (lambda, num_folds, etc)</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;  domains: in, optional, type=intarr(n)</span>
<span class="comments">;    domains of input samples</span>
<span class="comments">;  in_rank: in, optional, type=fix</span>
<span class="comments">;    rank of transform to calculate (default = k-1)</span>
<span class="comments">;  rank: out, required, type=fix</span>
<span class="comments">;    rank of calculated transform</span>
<span class="comments">;  verbose: in, optional, type=boolean</span>
<span class="comments">;    print verbose output to console</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
<a id="hiihat_mdmc_xvalidate:source"></a>function hiihat_mdmc_xvalidate, data, labels, reg_parms, domains=domains,$
                                in_rank=in_rank, rank=rank, verbose=verbose

  debug = hiihat_get_config_parm('debug')
  title='hiihat_mdmc_xvalidate'
  if debug then print, "Entering "+title
  if not keyword_set(verbose) then verbose=0

  data_size = size(data)
  n = data_size[1] <span class="comments">;; number of samples</span>
  nb = data_size[2] <span class="comments">;; number of bands</span>

  <span class="comments">;; all classes from the same domain - traditional FDA</span>
  if not keyword_set(domains) then domains = intarr(n)+1

  <span class="comments">;; get unique labels and domains</span>
  ulab = labels[uniq(labels,sort(labels))]
  udom = domains[uniq(domains,sort(domains))]
  
  k = n_elements(ulab) <span class="comments">;; number of classes</span>
  D = n_elements(udom) <span class="comments">;; number of domains</span>

  if verbose then begin
     print, "Evaluating regularization parameters for "+strtrim(n,2)+' samples of dimensionality '+strtrim(nb,2)
     print, "Total classes: "+strtrim(k,2), " domains: "+strtrim(D,2)     
  endif

  num_folds = reg_parms.num_folds
  lambda_min = reg_parms.lambda_min
  lambda_max = reg_parms.lambda_max
  lambda_delta = reg_parms.lambda_delta

  num_lambda = ceil((lambda_max-lambda_min)/lambda_delta)  
  
  <span class="comments">;; default to euclidean</span>
  A_best = identity(nb) 
  
  acc_lda = fltarr(num_lambda)
  acc_euc = 0.0
  envi_report_init, "Learning metric", base=base, /INTERRUPT, title=title 
  envi_report_inc, base, num_folds-1
  for fi=0,num_folds-1 do begin
     envi_report_stat, base, i, num_folds-1, cancel=cancel   
     if cancel then begin
        goto, cleanup
     endif

     if verbose then print, "Fold "+strtrim(fi,2)

     hiihat_split_data, labels, num_folds, domains=domains, verbose=verbose, $
                        train_idx=fold_tr, test_idx=fold_te
     
     tr_dat = data[fold_tr,*]
     te_dat = data[fold_te,*]
     tr_lab = labels[fold_tr]
     te_lab = labels[fold_te]
     tr_dom = domains[fold_tr]
     te_dom = domains[fold_te]

     <span class="comments">;; re-initialize fold_{tr,te} </span>
     temp=size(temporary(fold_tr))
     temp=size(temporary(fold_te))

     pred = hiihat_classify_mindist(tr_dat,tr_lab,te_dat)
     acc_euc += float(total(pred eq te_lab))/n_elements(te_lab)
     
     lambda = lambda_min
     for li=0,num_lambda-1 do begin
        <span class="comments">;; get the LDA transformation matrix</span>
        reg_parms.lambda = lambda
        lambda_cur = lambda 
        lambda = min([1.0,lambda+lambda_delta]) 
        A = hiihat_mdmc_lda(tr_dat, tr_lab, domains=tr_dom, $
                            reg_parms=reg_parms, rank=rank, $
                            verbose=verbose, error=error)
        if error ne 0 then begin
           print, 'Error: Singular matrix with lambda=', strtrim(lambda_cur,2)
           continue
        endif
        
        <span class="comments">;; apply transformation matrix</span>
        tr_datA = reform(A ## tr_dat, n_elements(tr_lab), rank)
        te_datA = reform(A ## te_dat, n_elements(te_lab), rank)
     
        pred = hiihat_classify_mindist(tr_datA,tr_lab,te_datA)
        lda_acc = float(total(pred eq te_lab))/n_elements(te_lab)
        acc_lda[li] += lda_acc

        if verbose then print, "lambda=", lambda_cur, " LDA acc=",lda_acc        

        <span class="comments">;; clear rank parameter for next iteration</span>
        temp=size(temporary(rank))
     endfor
  endfor
  envi_report_init, base=base, /finish 

  acc_best = max(acc_lda,max_sub)/num_folds
  lambda_best = lambda_min+(lambda_delta*max_sub)

  if verbose then begin
     print, 'LDA best lambda=', lambda_best, ' acc=', acc_best
     print, "EUC acc=", acc_euc/num_folds
  endif
  
  reg_parms.lambda = lambda_best
  A_best = hiihat_mdmc_lda(data, labels, domains=domains, $
                           reg_parms=reg_parms, rank=rank, $
                           verbose=verbose, error=error)
cleanup:
  if debug then print, "Exiting "+title
  return, A_best
end
</code>
    </div>
  </body>
</html>