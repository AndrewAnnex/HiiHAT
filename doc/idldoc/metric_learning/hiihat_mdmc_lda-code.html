<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.3 on Wed Sep 14 19:26:29 2011 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hiihat_mdmc_lda.pro (HiiHAT)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hiihat_mdmc_lda.pro (HiiHAT)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+ </span>
<span class="comments">; Calculate a LDA-based transform for multi-class/multi-domain input data. </span>
<span class="comments">;</span>
<span class="comments">; :Author: Brian Bue</span>
<span class="comments">;</span>
<span class="comments">; :Categories: </span>
<span class="comments">;  metric_learning</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;  data: in, required, type="fltarr(n,nb)"</span>
<span class="comments">;    labeled data to determine transform </span>
<span class="comments">;  labels: in, required, type="intarr(n)"</span>
<span class="comments">;    labels for each of the data points</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;  domains: in, optional, type=intarr(n)</span>
<span class="comments">;    domains of input samples</span>
<span class="comments">;  reg_parms: in, optional, type=struct</span>
<span class="comments">;    regularization parameters</span>
<span class="comments">;  in_rank: in, optional, type=fix</span>
<span class="comments">;    rank of transform to calculate (default = k-1)</span>
<span class="comments">;  rank: out, optional, type=fix</span>
<span class="comments">;    rank of calculated transform</span>
<span class="comments">;  verbose: in, optional, type=boolean</span>
<span class="comments">;    print verbose output to console</span>
<span class="comments">;  error: out, optional, type=fix</span>
<span class="comments">;    error code if method fails (e.g., due to singular matrix)</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2011, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;-</span>
<a id="hiihat_mdmc_lda:source"></a>function hiihat_mdmc_lda, data, labels, domains=domains, reg_parms=reg_parms,$
                          in_rank=in_rank, rank=rank, verbose=verbose, error=error

  data_size = size(data)
  n = data_size[1] <span class="comments">;; number of samples</span>
  nb = data_size[2] <span class="comments">;; number of bands</span>

  <span class="comments">;; all classes from the same domain - traditional FDA</span>
  if not keyword_set(domains) then domains = intarr(n)+1

  <span class="comments">;; get unique labels and domains</span>
  ulab = labels[uniq(labels,sort(labels))]
  udom = domains[uniq(domains,sort(domains))]
  
  k = n_elements(ulab) <span class="comments">;; number of classes</span>
  D = n_elements(udom) <span class="comments">;; number of domains</span>

  if verbose then begin
     print, "Calculating LDA transform for "+strtrim(n,2)+' samples of dimensionality '+strtrim(nb,2)
     print, "Total classes: "+strtrim(k,2), " domains: "+strtrim(D,2)     
  endif

  Mw = fltarr(nb,nb) <span class="comments">;; within class scatter matrix</span>
  Mb = fltarr(nb,nb) <span class="comments">;; between class scatter matrix</span>

  <span class="comments">;; within-class scater evaluated over all domains</span>
  for i=0, k-1 do begin
     classdat = data[where(labels eq ulab[i]),*]
     Mw += correlate(transpose(classdat),/covariance)
  end
  Mw /= k

  <span class="comments">;; between-class scatter evaluated over independent domains</span>
  for j=0, D-1 do begin
     dom_idx = where(domains eq udom[j])
     dom_dat = data[dom_idx,*]
     dom_avg = total(dom_dat, 1)/float(n_elements(dom_idx))
     for i=0, k-1 do begin
        labdom_idx = where(labels eq ulab[i] and domains eq udom[j])
        n_labdom = n_elements(labdom_idx)
        if n_labdom eq 0 then continue
        labdom_dat = data[labdom_idx,*]
        labdom_avg = total(labdom_dat, 1)/float(n_labdom)        
        labdom_std = labdom_avg-dom_avg
        Mb += n_labdom * matrix_multiply(labdom_std,labdom_std,/btranspose)
     end
  end
  Mb /= n

  <span class="comments">;; regularize!</span>
  if keyword_set(reg_parms) then begin
     switch reg_parms.reg_type of
        'constant': begin
           lambda = reg_parms.lambda     
           if lambda lt 0 or lambda gt 1 then begin
              print, 'Error: Lambda outside of [0,1] range'
              A = identity(nb)
              goto, cleanup
           endif
           Mw = (1.0-lambda)*Mw + lambda*identity(nb)
        end
     endswitch
  endif else begin
     if verbose then print, 'No regularization parameters provided. Skipping.'
  endelse

  <span class="comments">;; solve Mb / Mw eigensystem (and catch singluar matrix errors)</span>
  catch, error

  S = matrix_multiply(Mb,invert(Mw,/double))
  eval = hqr(elmhes(S,/double), /double) 
  evec = eigenvec(S,eval,/double)  
  
  if error ne 0 then begin
      print, 'MDMC-LDA error: ', !ERROR_STATE.MSG  
      <span class="comments">;; default to squared euclidean</span>
      A = identity(nb)
      goto, cleanup
   endif

  <span class="comments">;; Eigenvectors are not generally unique.  </span>
  <span class="comments">;; Multiply each eigenvector by a complex scaling  </span>
  <span class="comments">;; factor to force the initial term to be real.    </span>
  <span class="comments">;; This normalization ensures a unique solution.  </span>
  for i=0,nb-1 do evec[*,i] *= abs(evec[0,i])/evec[0,i]  

  <span class="comments">;; project into dimension k-1 (or smaller, if desired) space</span>
  if not keyword_set(in_rank) then rank = k-1 else rank = in_rank

  if rank gt nb then begin
     print, "Warning: more classes than available bands, reducing rank"
     rank = nb
  endif

  if rank gt k-1 then $
     print, "Warning: rank > #classes-1, output may be unstable"

  eval_sort = reverse(sort(eval))
  if verbose then begin
     print, "Rank:", rank
     print, "Eigenvals:", double(eval[eval_sort])
  endif

  if eval_sort[0] lt 0 then $
     print, 'Warning: largest eigenvalue &lt; 0, degenerate transform'

  A = double(evec[*,eval_sort[0:rank-1]]) <span class="comments">;; top eigenvectors</span>

  <span class="comments">;; reform if A is one dimensional</span>
  if (size(A))[0] eq 1 then A = reform(A,(size(A))[1],1)

cleanup:
  rank = (size(A))[2] <span class="comments">;; get final output rank which may have changed</span>
  return, A <span class="comments">;; mahalanobis M = AA^T</span>
end
</code>
    </div>
  </body>
</html>