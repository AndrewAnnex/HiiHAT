<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.3 on Wed Sep 14 19:26:30 2011 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hiihat_segment_felzenszwalb.pro (HiiHAT)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hiihat_segment_felzenszwalb.pro (HiiHAT)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">

<a id="find_root:source"></a>function find_root, elements, a
<span class="comments">;+</span>
<span class="comments">; find the root index associated with this node</span>
<span class="comments">; </span>
<span class="comments">; :Categories: segmentation</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;  elements: in, required, type="fix(N,3)"</span>
<span class="comments">;   an Nx3 array with each column giving [parent rank size]</span>
<span class="comments">;   note that the parent field is another index  that doesn't necessarily</span>
<span class="comments">;   indicate the direct parent, just some node higher in the tree.  By </span>
<span class="comments">;   following these indices we'll eventually get to a's root</span>
<span class="comments">;  a: in, required, type=fix</span>
<span class="comments">;   the node index</span>
<span class="comments">;-</span>
    ind = ulong(a)
    while (ind ne elements[ind,0]) do begin
        ind = elements[ind,0]
    endwhile
    elements[a,0] = ind <span class="comments">; optimize by updating direct parent of query node </span>
    return, ulong(ind)
end

<a id="join_tree:source"></a>pro join_tree, elements, a, b
<span class="comments">;+</span>
<span class="comments">; join the (disjoint) trees with root nodes a and b</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;  elements: in, required, type="lonarr(N,3)"</span>
<span class="comments">;   an Nx3 array with each column giving [parent rank size]</span>
<span class="comments">;  a: in, required, type=long</span>
<span class="comments">;   root node a</span>
<span class="comments">;  b: in, required, type=long</span>
<span class="comments">;   root node b</span>
<span class="comments">;  </span>
<span class="comments">; :Categories: segmentation</span>
<span class="comments">;-</span>
    if (elements[a,1] gt elements[b,1]) then begin 
        elements[b,0] = a
        elements[a,2] = elements[a,2] + elements[b,2]
    endif else begin
        elements[a,0] = b
        elements[b,2] = elements[a,2] + elements[b,2]
        if (elements[a,1] eq elements[b,1]) then $
            elements[b,1] = elements[b,1] + ulong(1)
    endelse
end

<span class="comments">;+</span>
<span class="comments">;  Segment a hyperspectral image using the </span>
<span class="comments">;  "efficient graph-based segmentation" approach of Pedro Felzenszwalib et al.</span>
<span class="comments">;  We omit their smoothing step (presume that the data is already clean).</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   segmentation </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;  in_file_fid: in, required, type="fltarr(ns,nl,nb)"</span>
<span class="comments">;    fid of input image to be segmented</span>
<span class="comments">;  c: in, required, type=float</span>
<span class="comments">;    threshold parameter, larger values prefer larger segment sizes</span>
<span class="comments">;  min_size: in, required, type=fix</span>
<span class="comments">;    minimum segment size in pixels</span>
<span class="comments">;  dist_metric: in, required, type=string</span>
<span class="comments">;    distance metric to use in segmentation (default euc^2)</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;  verbose: in, optional, type=boolean</span>
<span class="comments">;    enable verbose console output</span>
<span class="comments">;  use_dims: in, optional, type="longarr"</span>
<span class="comments">;    user defined dimensions</span>
<span class="comments">;  gui_status: in, optional, type=boolean</span>
<span class="comments">;    enable gui_status</span>
<span class="comments">;  out_filename: in, required, type=string</span>
<span class="comments">;    output file name </span>
<span class="comments">;  in_memory: in, optional, type=boolean</span>
<span class="comments">;    output to memory rather than file</span>
<span class="comments">;  r_fid: out, required, type=fid</span>
<span class="comments">;    fid of output segmentation (either file or memory)</span>
<span class="comments">;  permute_segments: in, optional, type=boolean</span>
<span class="comments">;    randomly permute segment ids </span>
<span class="comments">;  M: in, optional, type="fltarr(nb,nb)"</span>
<span class="comments">;    square, symmmetric matrix to use in mahalanobis distance (ignored if</span>
<span class="comments">;    dist_metric is not "mahalanobis")</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;   hiihat_segment_felzenszwalb, in_file_fid, c, min_size, dist_metric,</span>
<span class="comments">;                               out_filename=out_filename, in_memory=in_memory, </span>
<span class="comments">;                               r_fid=seg_fid, verbose=verbose, use_dims=use_dims,</span>
<span class="comments">;                               save_mean=save_mean, mean_image_name=mean_image_name, </span>
<span class="comments">;                               gui_status=gui_status</span>
<span class="comments">; </span>
<span class="comments">; :History:</span>
<span class="comments">;   2009 (DRT): Initial implementation</span>
<span class="comments">;</span>
<span class="comments">;   Dec 31, 2010 (BDB): docstr added</span>
<span class="comments">;  </span>
<span class="comments">; :Author: David Ray Thompson</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;  Copyright 2009, by the California Institute of Technology. ALL RIGHTS</span>
<span class="comments">;  RESERVED. United States Government Sponsorship acknowledged. Any commercial</span>
<span class="comments">;  use must be negotiated with the Office of Technology Transfer at the</span>
<span class="comments">;  California Institute of Technology.</span>
<span class="comments">; </span>
<span class="comments">;  This software may be subject to U.S. export control laws and regulations.  By</span>
<span class="comments">;  accepting this document, the user agrees to comply with all applicable U.S.</span>
<span class="comments">;  export laws and regulations.  User has the responsibility to obtain export</span>
<span class="comments">;  licenses, or other export authority as may be required before exporting such</span>
<span class="comments">;  information to foreign countries or providing access to foreign persons.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<a id="hiihat_segment_felzenszwalb:source"></a>pro hiihat_segment_felzenszwalb, in_file_fid, c, min_size, dist_metric, M=M, $
                                 out_filename=out_filename, in_memory=in_memory, $
                                 r_fid=seg_fid, verbose=verbose, $
                                 use_dims=use_dims, gui_status=gui_status, $                                 
                                 permute_segments=permute_segments

    debug = hiihat_get_config_parm('debug')
    title='hiihat_segment_felzenszwalb'
    if debug then print, "Entering "+title 

    if not keyword_set(verbose) then verbose = 0
    if not keyword_set(gui_status) then gui_status = 0
    if not keyword_set(in_memory) then in_memory = 0
    if not keyword_set(permute_segments) then permute_segments = 0
   
    mod_step = 100

    finite_max = hiihat_get_config_parm('finite_max')
    if finite_max eq 0 then finite_max = 10000.0 <span class="comments">;;!VALUES.F_INFINITY </span>

    hiihat_assert, in_memory or keyword_set(out_filename), $
            'Neither in_memory or out_filename defined', title=title

    hiihat_assert, c gt 0.0, 'C cannot be zero or negative', title=title
    hiihat_assert, min_size ge 1, 'min_size must be >= 1', title=title
  

    envi_file_query, in_file_fid, dims=dims, nb = nb, ns = nc, nl = nr
    
    if not keyword_set(use_dims) then use_dims = dims   
    
    if verbose then begin 
       print, "Checking redundant array size on disk: ", dims
       print, "Selected image has ",nb," bands ",nc," samples ",nr," lines" 
       print, "User wants ", use_dims
    endif

    <span class="comments">;; overwrite the samples and lines based on user requested region</span>
    nc = use_dims[2]-use_dims[1]+1
    nr = use_dims[4]-use_dims[3]+1

    <span class="comments">;;if (min_size gt nc) or (min_size gt nr) then begin</span>
    <span class="comments">;;   min_size = min([nc,nr])</span>
    <span class="comments">;;   if verbose then print, "min_size > image dims, setting to smallest dimension: ", min_size</span>
    <span class="comments">;;endif</span>

    if verbose then print, "User subselected ",nc," samples ",nr," lines"
    
    <span class="comments">;; use_dims supplants the "dims" var from above, using only a subset if</span>
    <span class="comments">;; the user desires.</span>

    envi_report_init, "Loading image data", base=base, /INTERRUPT, title=title 
    envi_report_inc, base, nb-1
    data = fltarr(nc, nr, nb)
    for i=0,nb-1 do begin
       if i mod mod_step eq 0 then begin
          envi_report_stat, base, i, nb-1, cancel=cancel   
          if cancel then goto, cleanup
       endif
       data[*,*,i] = envi_get_data(fid=in_file_fid, dims=use_dims, pos=i)
    endfor
    envi_report_init, base=base, /finish 
        
    nels = ulong(nc)*ulong(nr)
    nedges = ulong(0) 
    edges    = lonarr(nels*4,2) <span class="comments">; [a, b] linear indices</span>
    weights  = fltarr(nels*4)+finite_max  <span class="comments">; spectrum difference represented by the edge</span>

    <span class="comments">; create a forest of disjoint root nodes, represented by the 'elements'</span>
    <span class="comments">; array with columns corresponding to [parent, rank, size].</span>
    <span class="comments">; For root nodes, the parent indicates the node's own index into the </span>
    <span class="comments">; elements array.  </span>
    elements = [[lindgen(nels)],[lonarr(nels)],[1+lonarr(nels)]]
    thresholds = fltarr(nels) + (float(c)/1.0)
 
    <span class="comments">; Create the progress bar.</span>
    envi_report_init, "Building edge graph", base=base, /INTERRUPT, title=title 
    envi_report_inc, base, nc-1

    <span class="comments">; build an 8-connected graph of edges</span>
    if verbose then print, "Building edge graph"
    for i=ulong(0),nc-1 do begin
       if i mod mod_step eq 0 then begin
          envi_report_stat, base, i, nc-1, cancel=cancel                                             
          if cancel then goto, cleanup
       endif
              
       for j=ulong(0),nr-1 do begin            
            a = i+j*nc
        
            if (i lt nc-1) then begin
                b = ((i+1)+(j*nc))
                edges[nedges,0] = a
                edges[nedges,1] = b 
                weights[nedges] = hiihat_spec_difference(data[i,j,*], $
                        data[i+1,j,*], dist_metric, /reject_zeros, M=M)
                nedges += 1
            endif

            if (j lt nr-1) then begin
                b = (i+(j+1)*nc)
                edges[nedges,0] = a
                edges[nedges,1] = b 
                weights[nedges] = hiihat_spec_difference(data[i,j,*], $
                        data[i,j+1,*], dist_metric, /reject_zeros, M=M)
                nedges += 1
            endif
            
            if ((i lt nc-1) and (j lt nr-1)) then begin
                b = ((i+1)+(j+1)*nc)
                edges[nedges,0] = a
                edges[nedges,1] = b 
                weights[nedges] = hiihat_spec_difference(data[i,j,*], $
                        data[i+1,j+1,*], dist_metric, /reject_zeros, M=M)
                nedges += 1   
            endif
            
            if ((i gt 0) and (j lt nr-1)) then begin
                b = ((i-1)+(j+1)*nc)
                edges[nedges,0] = a
                edges[nedges,1] = b 
                weights[nedges] = hiihat_spec_difference(data[i,j,*], $
                        data[i-1,j+1,*], dist_metric, /reject_zeros, M=M)
                nedges += 1   
            endif

        endfor
    endfor <span class="comments">;; graph complete</span>
    envi_report_init, base=base, /finish 


    <span class="comments">;; sort by weight</span>
    if verbose then print, "Sorting by weight"
    order = sort(weights)
    edges = edges[order,*]
    weights = weights[order]
    
    n_join_normal = 0L
    <span class="comments">;; segment</span>
    envi_report_init, "Segmenting image", base=base, /INTERRUPT, title=title 
    envi_report_inc, base, nedges-1

    if (verbose) then print, "Segmenting"
    for i=ulong(0), nedges-1 do begin
       if i mod mod_step eq 0 then begin
          envi_report_stat, base, i, nedges-1, cancel=cancel                                             
          if cancel then goto, cleanup
       endif

        a = find_root(elements, edges[i, 0])
        b = find_root(elements, edges[i, 1])

        if ((a ne b) and $
            (weights[i] le thresholds[a]) and $
            (weights[i] le thresholds[b])) then begin

            n_join_normal += 1
            join_tree, elements, a, b
            a = find_root(elements, a)
            thresholds[a] = weights[i] + (c / float(elements[a,2]))
        endif 
    endfor
    envi_report_init, base=base, /finish 


<span class="comments">;; NOTE: There is a weirdness here. Minsize is somehow merging the "0"</span>
<span class="comments">;; object with various segments producing a rough, jagged segment</span>
<span class="comments">;; edge. Not sure why.</span>
<span class="comments">;; NOTE: Minsize is controlling almost all merging events at this time</span>
<span class="comments">;; due to our C choice, the noise characteristics of CRISM data, etc. </span>
    n_join_minsize = 0L
    <span class="comments">; remove small sets</span>
    envi_report_init, "Cleaning up small regions", base=base, /INTERRUPT, title=title 
    envi_report_inc, base, nedges-1

    if verbose then print, "Cleaning up small regions"
    for i=ulong(0), nedges-1 do begin       
        if i mod mod_step eq 0 then begin
          envi_report_stat, base, i, nedges-1, cancel=cancel                                             
          if cancel then goto, cleanup
        endif

        a = find_root(elements, edges[i, 0])
        b = find_root(elements, edges[i, 1])

        if ((a ne b) and $
            ((elements[a,2] lt min_size ) or $
             (elements[b,2] lt min_size )))  then begin <span class="comments">;and $</span>
<span class="comments">;          weights[i] lt HUGE and finite(weights[i]) then begin</span>
<span class="comments">;            print, "Minsize join with weights ",weights[i]," thresholds ",thresholds[a]," ",thresholds[b]</span>
            n_join_minsize += 1
            join_tree, elements, a, b
        endif
    endfor

    if verbose then print,"Normal joins ",n_join_normal,", minsize joins ",n_join_minsize

    <span class="comments">; write labels</span>
    if verbose then print, "Writing output"
    segmentation = ulonarr(nc, nr)

    <span class="comments">; map elements onto consecutive segment labels</span>
    nlabels = ulong(0) 
    label_map = lonarr((size(elements))[1])-long(1)
    
    if  n_elements(label_map) eq 0 then begin       
       ok = dialog_message('Empty label map in segmentation', $
                           title=title)
       goto, cleanup
    endif

    <span class="comments">;; populate segmentation map with labeled regions</span>
    for j=0,nr-1 do begin
       for i=0,nc-1 do begin
            label = find_root(elements, ulong(i)+ulong(j)*ulong(nc))
            if (label_map[label] eq -1) then begin
                label_map[label] = nlabels
                nlabels += ulong(1)
            endif
            segmentation[i,j] = label_map[label]
        endfor
    endfor

    if nlabels eq 0 then begin
       dialog="Segment labeling error: no labels found"
       if gui_status then ok=dialog_message(dialog,title=title) else $
          print, dialog       
       goto, cleanup
    endif

    if verbose then print,"Derived ",nlabels," segments"
    <span class="comments">;; Now rearrange all the superpixel</span>
    <span class="comments">;; labels randomly to avoid the smooth</span>
    <span class="comments">;; cascading monotonic labels that make</span>
    <span class="comments">;; it hard to distinguish superpixels by</span>
    <span class="comments">;; eye by label</span>
   
    if nlabels gt 1 then begin 
       if permute_segments then begin
          <span class="comments">;; randomly permute labels, 'seed' is a kwparam</span>
          newlabels = long(sort(randomu(seed, max(label_map)+1)))
          segmentation = newlabels[segmentation]
       endif
    endif else begin
       <span class="comments">;; if we only have a single label, then warn the user </span>
       ok = dialog_message('Warning: singleton segmentation', $
                           title=title)
    endelse

    unsigned_long = 13 <span class="comments">;; datatype for ulong</span>
    band_name = "Superpixels (c="+ strtrim(string(c),2)+", min="+$
            strtrim(string(min_size),2)+", metric="+dist_metric+")"

    if in_memory then begin
        envi_write_envi_file, segmentation, data_type = unsigned_long, $
            ns=nc, nl = nr, nb = 1, r_fid = seg_fid, $
            out_name="Superpixels", bnames = [band_name], $
            file_type=envi_file_type("ENVI Segmentation"),$
            /in_memory
    endif else begin
        <span class="comments">;;This trick is here to prevent the available bands from opening but</span>
        <span class="comments">;;still return an fid. envi_write_envi_file will always pop up that menu without /no_open,</span>
        <span class="comments">;;but with no_open the file is not accessible using the r_fid</span>

        envi_write_envi_file, segmentation, data_type = unsigned_long, $
                              ns=nc, nl = nr, nb = 1, r_fid = seg_fid, $
                              out_name=out_filename, bnames = [band_name], $
                              file_type=envi_file_type("ENVI Segmentation"), $
                              /no_open

        envi_file_mng, id = seg_fid, /remove
        envi_open_file, out_filename, r_fid = seg_fid, /no_realize
    endelse

cleanup:
    <span class="comments">;; close statusbar</span>
    envi_report_init, base=base, /finish 
    if debug then print,"Exiting "+title
end

</code>
    </div>
  </body>
</html>